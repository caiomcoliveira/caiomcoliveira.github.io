<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dart & Flutter Quiz</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/dart.min.js"></script>
  <link rel="stylesheet" href="https://caiomcoliveira.github.io/css/styles.css"  />
</head>

<body>
  <div class="quiz-container">
    <h2 id="question-title"></h2>
    <pre><code id="question-code" class="language-dart"></code></pre>
    <div class="choices" id="choices"></div>
    <button id="next-btn">Next</button>
    <div id="result"></div>
  </div>

  <script>
    const questions = [
      {
        title: '1. What will this Dart code print, and why?',
        code: `void main() {
  var a = [1, 2, 3];
  var b = a;
  b.add(4);
  print(a.length);
}`,
        choices: ['3 — Lists are copied by value', '4 — Lists are reference types', 'Error — Reassignment not allowed', 'Undefined behavior'],
        correct: 1,
      },
      {
        title: '2. What is the main difference between "final" and "const" in Dart?',
        code: ``,
        choices: [
          '"const" creates compile-time constants, "final" is runtime constant',
          '"final" and "const" behave identically in all cases',
          '"const" variables can be reassigned once',
          '"final" values are always mutable',
        ],
        correct: 0,
      },
      {
        title: '3. What will this code print and why?',
        code: `void main() async {
  print('A');
  Future(() => print('B'));
  scheduleMicrotask(() => print('C'));
  print('D');
}`,
        choices: [
          'A B C D',
          'A D C B',
          'A C D B',
          'C A D B',
        ],
        correct: 2,
      },
      {
        title: '4. In Flutter, which approach minimizes rebuilds for performance optimization?',
        code: ``,
        choices: [
          'Using StatefulWidget everywhere',
          'Using const constructors and immutable widgets',
          'Wrapping widgets in setState()',
          'Using ListView.builder for static content',
        ],
        correct: 1,
      },
      {
        title: '5. In a StatefulWidget, when is the "initState" method called?',
        code: ``,
        choices: [
          'Every time the widget rebuilds',
          'Once when the State object is inserted into the widget tree',
          'Only when setState is called',
          'Before the widget’s constructor',
        ],
        correct: 1,
      },
      {
        title: '6. What will this code display and why?',
        code: `class MyWidget extends StatelessWidget {
  final String text;
  const MyWidget(this.text);

  @override
  Widget build(BuildContext context) {
    return Text(text.toUpperCase());
  }
}

void main() {
  runApp(const MyWidget('flutter'));
}`,
        choices: ['flutter', 'FLUTTER', 'Error: text not initialized', 'Nothing'],
        correct: 1,
      },
      {
        title: '7. What is the main advantage of using an isolate in Dart?',
        code: ``,
        choices: [
          'To share mutable memory between threads',
          'To perform heavy computation without blocking the main isolate',
          'To speed up synchronous UI rebuilds',
          'To replace async/await in I/O operations',
        ],
        correct: 1,
      },
      {
        title: '8. What will this async Dart code print?',
        code: `Future<void> main() async {
  print('A');
  await Future(() => print('B'));
  print('C');
  Future(() => print('D'));
  print('E');
}`,
        choices: [
          'A B C D E',
          'A B C E D',
          'A C B E D',
          'A B E C D',
        ],
        correct: 1,
      },
    ];

    let current = 0;
    let score = 0;

    const titleEl = document.getElementById('question-title');
    const codeEl = document.getElementById('question-code');
    const codeBlockEl = codeEl.parentElement;
    const choicesEl = document.getElementById('choices');
    const nextBtn = document.getElementById('next-btn');
    const resultEl = document.getElementById('result');

    function loadQuestion() {
      const q = questions[current];
      titleEl.textContent = q.title;

      if (q.code && q.code.trim() !== '') {
        codeEl.textContent = q.code;
        hljs.highlightElement(codeEl);
        codeBlockEl.style.display = 'block';
      } else {
        codeEl.textContent = '';
        codeBlockEl.style.display = 'none';
      }

      choicesEl.innerHTML = '';
      q.choices.forEach((choice, i) => {
        const label = document.createElement('label');
        label.innerHTML = `<input type="radio" name="choice" value="${i}"> ${choice}`;
        choicesEl.appendChild(label);
      });

      resultEl.textContent = '';
      if (current === questions.length - 1) nextBtn.textContent = 'Finish';
    }

    nextBtn.addEventListener('click', () => {
      const selected = document.querySelector('input[name="choice"]:checked');
      if (!selected) {
        alert('Please select an answer.');
        return;
      }
      if (parseInt(selected.value) === questions[current].correct) score++;
      current++;
      if (current < questions.length) {
        loadQuestion();
      } else {
        titleEl.textContent = 'Quiz Completed!';
        codeEl.textContent = '';
        codeBlockEl.style.display = 'none';
        choicesEl.innerHTML = '';
        nextBtn.style.display = 'none';
        resultEl.textContent = `You scored ${score} / ${questions.length}`;
      }
    });

    loadQuestion();
  </script>
</body>

</html>